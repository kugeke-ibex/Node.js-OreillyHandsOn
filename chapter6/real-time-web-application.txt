SSE
ポーリングはリアルタイムWebアプリケーションを実装するための最もシンプルな手段。
クライアントはユーザー捜査をトリガーとしないWeb APIの呼び出しを一定間隔で繰り返し、定期的に状態をサーバーと同期する。
サーバーサイドでは特別な実装は必要なく、クライアントサイドでsetTimeout()のようなAPIを使い、一定間隔でWebAPIを呼び出す。
ポーリングの欠点はサーバーでデータが更新されるタイミングとは無関係に、クライアントからの状態の取得が行われます。
更新がなければ無駄なリクエストとなり、サーバーがレスポンスを返した直後に更新があると反映までに遅延が発生します。

ロングポーリングはHTTPリクエストを受け取ったサーバがデータの更新を待ってレスポンスを返すことでリアルタイム性を実現する方法です。
クライアントはレスポンスをロングポーリングのレスポンスを受け取ったらすぐにまたリクエストを送信し、次のデータ更新に備えます。
サーバーサイトでは即時に状態を返すWebAPIとは別に、対象のデータの更新を監視し、更新されたタイミングでレスポンスを返す
ロングポーリング用のWebAPIを用意する必要があります。
クライアントからは、何らかの方法で初期状態を取得した後、ロングポーリング用のWebAPIを実行してデータの更新を待機します。
ロングポーリングはサーバーでのデータ更新のタイミングに合わせてクライアントに状態が同期されるため、ポーリングと比べると効率的です。
ただし、サーバーがレスポンスを返してから次のリクエストを受け取るまでは接続が切れるので、この間に発生したデータ更新の反映は遅延します。
更新のたびに新たなHTTPリクエストが発生することも、更新の頻度によってはデメリットになります。

SSE(Server Sent Events)は一度確立したHTTP接続を保持したまま、データ更新が発生するたびにその接続の中でクライアントにデータを送信する方法です。
サーバーレスポンスのContent-Typeヘッダーをtext/event-streamに設定、リクエストを受信したタイミングと、それ以降データ更新が発生するタイミングで
都度レスポンスにデータを書き込みます。クライアントはEventSourceというAPIを使ってSSEのWebAPIにアクセスします。

SSEのメッセージに含められるフィールド
・フィールド名 : 説明
・data       : SSEによって送信したいデータ
・id         : イベントのID。この値はEventSourceインスタンスに保持され、接続の切断に伴う再接続のリクエスト時にLast-Event-IDヘッダーに指定される。
               このヘッダーは例えば、サーバーが再接続してきたクライアントに対し、そのクライアントが最後に受信したイベントより後のイベントを即時送信
               するような用途で使える。
・event      : イベント名を表す文字列。クライアントサイドでEventSourceインスタンスのaddEventListenerメソッドを利用してイベントをハンドリングする際に
               引数にこのイベント名を指定する。このフィールドを指定しなかった場合、デフォルトでmessageというイベント名になる
・retry      : 接続の切断に伴う再接続を行うまでの時間(ミリ秒)。指定しなかった場合でも、ブラウザの実装に応じてある間隔で自動的に再接続が行われる。

それぞれのフィールは改行によって区切られ、フィールド名とその値はコロン(:)で区切ります。
また、コロンで始まる行はコメント文になります。
SSEで長時間メッセージが送信されないと接続がタイムアウトする場合がありますが、定期的にコメントだけのメッセージを送ってタイムアウトを防ぐという用途があります。
メッセージの最後では2回改行し、(\n\nを含め)そのメッセージが完結したことを示します。

SSEのメッセージの例
: id,data,event,retryを含むメッセージ
id: 1
data: Hello
event: greeting
retry: 1000
: この後ろで2回改行してメッセージを完結

: dataだけのメッセージ
data: data only

: コメントだけのメッセージ

4つのフィールドのうち、dataフィールドだけは連続する複数行に分けて記述できます。
その時、各行の文字列は改行(\n)によって連結されます。

data: Hello,
data: World

は

data: Hello,\nWorld

と等価です

SSEは1つの接続を保持し続けてその中で何回もデータを送信するため、ロングポーリングのように接続の一時的な切断が起こりません。
また、データの更新が発生するたびにHTTPの再接続が必要となるロングポーリングと比べ、1回の接続で済ませられるためHTTP接続のコストを抑えられます。


WebSocket
WebSocketはSSEと同様にリアルタイムWebアプリケーションを実現可能にしますが、主な違いはクライアント・サーバー間での通信が双方向で可能なこと。
(SSEではクライアントからの初めてのリクエスト後はサーバーからクライアントの向きにしかデータを送信できません)および、プロトコルがHTTPではないことです.
WebSocketの通信開始はハンドシェイクと呼ばれるプロセスによるクライアント・サーバー間の接続を確立します。
ハンドシェイクは標準的はHTTPリクエスト、レスポンスによって行われます。
クライアントからのWebSocketでの接続要求を示すHTTPリクエストに対し、サーバーからステータスコード101(Switching Protocols)で適切な
ヘッダが設定されたHTTPレスポンスを返します。これ以降はWebSocketによるクライアント・サーバ間での双方向通信が可能になります。
一度確立した接続を使い続けるため、都度HTTP接続するようなコストが発生しないのは、SSEと同様です。
さらに、クライアントからサーバへもデータ送信できることは、SSEにはない特徴。
デメリットとしては、HTTPではない独自のプロトコルを利用することで、取り扱いが複雑なのとファイアウォールやウイルス対策ソフトにより、
WebSocketプロトコルによる通信が妨害されることもあり得ます。また、SSEのようなリトライの仕組みデフォルトには組み込まれていません。
WebSocketはネットワーク環境などの制約によって、利用できないケースがあるため、ライブラリもそのような制約かでの代替手段(フォールバック)を提供するものと、
純粋にWebSocketの機能のみ提供するものがあります。
前者のライブラリでは通常クライアントサイドの実装もセットで提供されており、WebSocketの利用可否を判定してフォールバックする処理を、利用者側に
意識させることなく行ってくれます。有名なのはSocket.IOです。一方純粋な機能を提供するのはwsが代表的でSocket.IOの内部的にも利用されています。

